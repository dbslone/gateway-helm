{{- if .Values.replicasetPruner.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "gateway-helm.fullname" . }}-replicaset-pruner
  labels:
    {{- include "gateway-helm.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "argocd.argoproj.io/hook": PostSync
    "argocd.argoproj.io/hook-delete-policy": HookSucceeded
spec:
  ttlSecondsAfterFinished: {{ .Values.replicasetPruner.ttlSecondsAfterFinished | default 300 }}
  backoffLimit: {{ .Values.replicasetPruner.backoffLimit | default 3 }}
  template:
    metadata:
      labels:
        {{- include "gateway-helm.labels" . | nindent 8 }}
    spec:
      serviceAccountName: {{ include "gateway-helm.serviceAccountName" . }}
      restartPolicy: Never
      containers:
      - name: replicaset-pruner
        image: {{ .Values.replicasetPruner.image.repository }}:{{ .Values.replicasetPruner.image.tag }}
        imagePullPolicy: {{ .Values.replicasetPruner.image.pullPolicy | default "IfNotPresent" }}
        command:
        - /bin/sh
        - -c
        - |
          echo "Starting replicaset pruning job..."
          
          # Get the deployment name
          DEPLOYMENT_NAME="{{ include "gateway-helm.fullname" . }}"
          KEEP_COUNT={{ .Values.revisionHistoryLimit | default 2 }}
          NAMESPACE="{{ .Release.Namespace }}"
          
          echo "Deployment: $DEPLOYMENT_NAME"
          echo "Namespace: $NAMESPACE"
          echo "Keeping up to $KEEP_COUNT old replicasets"
          
          # Verify deployment exists
          if ! kubectl get deployment "$DEPLOYMENT_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
            echo "Warning: Deployment $DEPLOYMENT_NAME not found, skipping pruning"
            exit 0
          fi
          
          # Get all replicasets that match the deployment's selector labels
          # Using label selector to find replicasets created by this deployment
          LABEL_SELECTOR="app.kubernetes.io/name={{ include "gateway-helm.name" . }},app.kubernetes.io/instance={{ .Release.Name }}"
          echo "Label selector: $LABEL_SELECTOR"
          
          # Method 1: Get replicasets by label selector
          RS_LIST=$(kubectl get rs -l "$LABEL_SELECTOR" -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null || echo "")
          
          # Method 2: If no replicasets found by label, try finding by deployment name pattern
          # Replicasets created by deployments follow pattern: <deployment-name>-<hash>
          if [ -z "$RS_LIST" ] || [ -z "$(echo "$RS_LIST" | grep -v '^$')" ]; then
            echo "No replicasets found by label selector, trying deployment name pattern..."
            RS_LIST=$(kubectl get rs -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null | grep "^${DEPLOYMENT_NAME}-" || echo "")
          fi
          
          if [ -z "$RS_LIST" ] || [ -z "$(echo "$RS_LIST" | grep -v '^$')" ]; then
            echo "No replicasets found for deployment $DEPLOYMENT_NAME"
            exit 0
          fi
          
          # Count replicasets (filter out empty lines)
          RS_ARRAY=$(echo "$RS_LIST" | grep -v '^$')
          RS_COUNT=$(echo "$RS_ARRAY" | wc -l | tr -d ' ')
          
          if [ "$RS_COUNT" = "0" ] || [ -z "$RS_COUNT" ]; then
            echo "No replicasets found to process"
            exit 0
          fi
          
          echo "Found $RS_COUNT replicaset(s)"
          echo "ReplicaSet list:"
          echo "$RS_ARRAY" | while IFS= read -r RS; do
            if [ -n "$RS" ]; then
              echo "  - $RS"
            fi
          done
          
          # Calculate how many to keep (revisionHistoryLimit + 1 for the active one)
          KEEP_TOTAL=$((KEEP_COUNT + 1))
          
          if [ "$RS_COUNT" -le "$KEEP_TOTAL" ]; then
            echo "Only $RS_COUNT replicaset(s) found, keeping all (limit: $KEEP_TOTAL)"
            echo "However, will still try to delete any ReplicaSets with 0 replicas..."
            # Don't exit, continue to check and delete any with 0 replicas
          else
            echo "Keeping $KEEP_TOTAL most recent replicaset(s)"
          fi
          
          # Get the current active ReplicaSet from the deployment
          # Method 1: Check deployment status for new ReplicaSet
          ACTIVE_RS=$(kubectl get deployment "$DEPLOYMENT_NAME" -n "$NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Progressing")].message}' 2>/dev/null | grep -oE '[a-z0-9-]+-[a-z0-9]{10}' | head -n 1 || echo "")
          
          # Method 2: Find newest ReplicaSet with replicas > 0
          if [ -z "$ACTIVE_RS" ]; then
            ACTIVE_RS=$(kubectl get rs -l "$LABEL_SELECTOR" -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.replicas}{"\n"}{end}' 2>/dev/null | grep -v -E "(\t0|\tnull|\t)$" | tail -n 1 | cut -f1 || echo "")
          fi
          
          # Method 3: Get newest ReplicaSet (most recent one is likely active)
          if [ -z "$ACTIVE_RS" ]; then
            ACTIVE_RS=$(echo "$RS_ARRAY" | tail -n 1)
          fi
          
          if [ -n "$ACTIVE_RS" ]; then
            echo "Active ReplicaSet: $ACTIVE_RS"
          else
            echo "Warning: Could not determine active ReplicaSet"
          fi
          
          # Also get all ReplicaSets that are owned by the deployment (for safety check)
          DEPLOYMENT_UID=$(kubectl get deployment "$DEPLOYMENT_NAME" -n "$NAMESPACE" -o jsonpath='{.metadata.uid}' 2>/dev/null || echo "")
          
          # Delete old replicasets (all except the last KEEP_TOTAL)
          DELETE_COUNT=$((RS_COUNT - KEEP_TOTAL))
          if [ "$DELETE_COUNT" -gt "0" ]; then
            echo "Will attempt to delete $DELETE_COUNT old replicaset(s)"
          fi
          
          # Process all replicasets and delete old ones with 0 replicas
          DELETED_COUNT=0
          SKIPPED_COUNT=0
          FAILED_COUNT=0
          
          # Determine which ReplicaSets to check for deletion
          if [ "$RS_COUNT" -gt "$KEEP_TOTAL" ]; then
            # Get the oldest replicasets to delete (all except the last KEEP_TOTAL)
            DELETE_RS=$(echo "$RS_ARRAY" | head -n "$DELETE_COUNT")
          else
            # Even if we have fewer than KEEP_TOTAL, check all for ones with 0 replicas
            DELETE_RS="$RS_ARRAY"
          fi
          
          echo ""
          echo "Processing ReplicaSets for deletion..."
          echo "$DELETE_RS" | while IFS= read -r RS; do
            if [ -z "$RS" ]; then
              continue
            fi
            
            echo ""
            echo "=========================================="
            echo "Processing replicaset: $RS"
            echo "=========================================="
            
            # Skip if this is the active ReplicaSet
            if [ "$RS" = "$ACTIVE_RS" ]; then
              echo "  â­ Skipping $RS (this is the active ReplicaSet)"
              continue
            fi
            
            # Verify this ReplicaSet is owned by the deployment (safety check)
            if [ -n "$DEPLOYMENT_UID" ]; then
              RS_OWNER=$(kubectl get rs "$RS" -n "$NAMESPACE" -o jsonpath='{.metadata.ownerReferences[0].uid}' 2>/dev/null || echo "")
              if [ -n "$RS_OWNER" ] && [ "$RS_OWNER" != "$DEPLOYMENT_UID" ]; then
                echo "  â­ Skipping $RS (not owned by deployment $DEPLOYMENT_NAME)"
                continue
              fi
            fi
            
            # Get full replicaset details
            RS_REPLICAS=$(kubectl get rs "$RS" -n "$NAMESPACE" -o jsonpath='{.status.replicas}' 2>/dev/null || echo "0")
            RS_SPEC=$(kubectl get rs "$RS" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
            RS_READY=$(kubectl get rs "$RS" -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            RS_AVAILABLE=$(kubectl get rs "$RS" -n "$NAMESPACE" -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo "0")
            
            # Handle null values
            if [ "$RS_REPLICAS" = "null" ] || [ -z "$RS_REPLICAS" ]; then
              RS_REPLICAS="0"
            fi
            if [ "$RS_SPEC" = "null" ] || [ -z "$RS_SPEC" ]; then
              RS_SPEC="0"
            fi
            if [ "$RS_READY" = "null" ] || [ -z "$RS_READY" ]; then
              RS_READY="0"
            fi
            if [ "$RS_AVAILABLE" = "null" ] || [ -z "$RS_AVAILABLE" ]; then
              RS_AVAILABLE="0"
            fi
            
            echo "  Status: spec.replicas=$RS_SPEC, status.replicas=$RS_REPLICAS, ready=$RS_READY, available=$RS_AVAILABLE"
            
            # Delete if ReplicaSet has no replicas (check all status fields)
            # Delete if spec is 0 OR all status fields are 0
            CAN_DELETE=false
            REASON=""
            
            if [ "$RS_SPEC" = "0" ] || [ -z "$RS_SPEC" ]; then
              CAN_DELETE=true
              REASON="spec.replicas=0"
            elif [ "$RS_REPLICAS" = "0" ] && [ "$RS_READY" = "0" ] && [ "$RS_AVAILABLE" = "0" ]; then
              CAN_DELETE=true
              REASON="all status fields are 0"
            fi
            
            if [ "$CAN_DELETE" = "true" ]; then
              echo "  ðŸ—‘ Attempting to delete replicaset $RS ($REASON)"
              DELETE_OUTPUT=$(kubectl delete rs "$RS" -n "$NAMESPACE" --ignore-not-found=true --wait=false 2>&1)
              DELETE_EXIT=$?
              
              if [ "$DELETE_EXIT" -eq 0 ]; then
                echo "  âœ“ Successfully deleted $RS"
                sleep 2
                # Verify deletion
                if ! kubectl get rs "$RS" -n "$NAMESPACE" >/dev/null 2>&1; then
                  echo "  âœ“ Verified: $RS no longer exists"
                else
                  echo "  âš  Warning: $RS still exists after deletion attempt"
                  echo "  Trying force delete..."
                  kubectl delete rs "$RS" -n "$NAMESPACE" --ignore-not-found=true --wait=false --grace-period=0 --force 2>&1
                  sleep 2
                  if ! kubectl get rs "$RS" -n "$NAMESPACE" >/dev/null 2>&1; then
                    echo "  âœ“ Force deleted $RS"
                  else
                    echo "  âœ— Force delete also failed for $RS"
                    echo "  Output: $DELETE_OUTPUT"
                  fi
                fi
              else
                echo "  âœ— Failed to delete $RS (exit code: $DELETE_EXIT)"
                echo "  Output: $DELETE_OUTPUT"
                echo "  Trying force delete..."
                FORCE_OUTPUT=$(kubectl delete rs "$RS" -n "$NAMESPACE" --ignore-not-found=true --wait=false --grace-period=0 --force 2>&1)
                FORCE_EXIT=$?
                if [ "$FORCE_EXIT" -eq 0 ]; then
                  echo "  âœ“ Force deleted $RS"
                  sleep 2
                else
                  echo "  âœ— Force delete also failed (exit code: $FORCE_EXIT)"
                  echo "  Output: $FORCE_OUTPUT"
                fi
              fi
            else
              echo "  â­ Skipping $RS (has active replicas: spec=$RS_SPEC, status=$RS_REPLICAS)"
            fi
          done
          
          echo ""
          echo "=========================================="
          echo "Final verification..."
          echo "=========================================="
          echo "Remaining ReplicaSets:"
          kubectl get rs -l "$LABEL_SELECTOR" -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp -o custom-columns=NAME:.metadata.name,REPLICAS:.status.replicas,READY:.status.readyReplicas,AGE:.metadata.creationTimestamp 2>/dev/null || echo "Could not list ReplicaSets"
          
          echo ""
          echo "Replicaset pruning job completed"
        resources:
          {{- with .Values.replicasetPruner.resources }}
          {{- toYaml . | nindent 10 }}
          {{- else }}
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
          {{- end }}
{{- end }}

